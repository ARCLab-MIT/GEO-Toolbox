import numpy as np
from search_parameters import *
from geoscope_util import safedex

class satellite_history:
    '''
    Contains astrometric data, slot history, event timeline, and metadata for a single satellite. Slot
    history is generated internally by satellite_history.find_slots(), but this method must be called 
    externally. Event annotations are generated by cluster_history.create_timeline() and stored here in 
    the pre-initialized satellite_history.events list. 
    '''
    def __init__(self,satcat:str):
        # Constants defined by load_tle_data
        self.satnum = str(satcat) if type(satcat) is int else satcat
        self.timestep = None
        # self.metaData = {}
        # Numpy Arrays populated by load_tle_data
        self.timestamps = None
        self.lon = None
        self.alt = None
        self.dr = None
        # Search Results
        self.slots = [] # in-station modes
        self.modes = [] # all modes: in-station, drift, etc.
        self.events = [] # event annotations
        self.retired = False
    
    def create_PoL(self): # TODO: isolate from satellite_history
        '''
        mode = {"satnum":str,           NORAD ID as string 
                "timeframe":list,       [start, end] of available history (list of datetimes)
                "entry":datetime,       timestamp of satellite's entry into slot or drift mode
                "exit":datetime,        timestamp of satellite's exit from slot or drift mode
                "lon":float,            mean longitude (degrees)
                "lon<":float,           max longitude (degrees)
                "lon>":float,           min longitude (degrees)
                "alt":float,            mean altitude (meters)
                "alt<":float,           max altitude (meters)
                "alt>":float,           min altitude (meters)
                "dr":float,             mean drift rate (degrees per day)
                "class":str            slot or drift
        '''
        mode = {}
        in_slot = False
        in_drift = True
        dex = None
        last_dexit = None
        dexNday = 24*3600/self.timestep
        t_range = len(self.dr.by_phase)-1
        def enter_mode(mode,tm,cstr):
            mode = {}
            # print(self.satnum,"entered",cstr,"mode @",round(self.lon[pt],1),"degrees on",str(self.timestamps[pt])[0:10])
            mode["satnum"] = self.satnum
            mode["timeframe"] = [self.timestamps[0],self.timestamps[-1]]
            if tm is None or tm == 0: mode["entry"] = None
            else: mode["entry"] = self.timestamps[tm]
            mode["exit"] = None
            mode["class"] = cstr
            if self.retired: mode["orbit"] = "graveyard/storage"
            else: mode["orbit"] = "GEO"
            dex = tm # flag t for new mode
            return mode, dex
        def exit_mode(mode,tm,dexm):
            sfdex = 0 if dexm is None else dexm
            # print(self.satnum,"exited",mode["class"],"mode @",round(self.lon[pt],1),"degrees on",str(self.timestamps[pt])[0:10])
            mode["exit"] = self.timestamps[tm] if tm+1 < t_range else None
            mode["lon"] = np.mean(self.lon[sfdex:tm]) if sfdex != tm else self.lon[tm]
            mode["lon<"] = np.max(self.lon[sfdex:tm]) if sfdex != tm else self.lon[tm]
            mode["lon>"] = np.min(self.lon[sfdex:tm]) if sfdex != tm else self.lon[tm]
            mode["alt"] = np.mean(self.alt[sfdex:tm]) if sfdex != tm else self.alt[tm]
            mode["alt<"] = np.max(self.alt[sfdex:tm]) if sfdex != tm else self.alt[tm]
            mode["alt>"] = np.min(self.alt[sfdex:tm]) if sfdex != tm else self.alt[tm]
            mode["dr p>"] = np.min(self.dr.by_phase[sfdex:tm]) if sfdex != tm else self.dr.by_phase[tm]
            mode["dr p<"] = np.max(self.dr.by_phase[sfdex:tm]) if sfdex != tm else self.dr.by_phase[tm]
            mode["dr m>"] = np.min(self.dr.by_mean[sfdex:tm]) if sfdex != tm else self.dr.by_phase[tm]
            mode["dr m<"] = np.max(self.dr.by_mean[sfdex:tm]) if sfdex != tm else self.dr.by_mean[tm]
            mode["dr m"] = np.mean(self.dr.by_mean[sfdex:tm]) if sfdex != tm else self.dr.by_mean[tm]
            mode["dr p"] = np.mean(self.dr.by_phase[sfdex:tm]) if sfdex != tm else self.dr.by_phase[tm]
            if mode["alt>"] >= max_geo_alt and not self.retired:
                mode["orbit"] = "graveyard/storage"
                self.events.append({"type":"supersync","time":self.timestamps[sfdex],"lon":self.lon[sfdex],"alt":self.alt[sfdex]})
                self.retired = True
            # if this is the last mode, check mean alt as well
            elif safedex(tm) >= t_range and mode["alt"] > max_geo_alt and not self.retired:
                for e in range(self.events):
                    t1 = mode["entry"] if mode["entry"] is not None else self.timestamps[0]
                    t2 = mode["exit"] if mode["exit"] is not None else self.timestamps[-1]
                    tss = None
                    no_sync = True
                    if t1 <= self.events[e]["time"] <= t2:
                        if e["type"] == "sync":
                            self.events.pop(e)
                            no_sync = False
                        elif e["type"] == "supersync":
                            if tss is None: tss = e
                            elif self.events[e]["time"] < self.events[tss]["time"]: 
                                self.events.pop(tss)
                                tss = e
                mode["orbit"] = "graveyard/storage"
                if tss is None and no_sync: self.events.append({"type":"supersync","time":self.timestamps[sfdex],"lon":self.lon[sfdex],"alt":self.alt[sfdex]})
                self.retired = True
            # if mode["class"] == "in slot" and np.abs(mode["lon<"]-mode["lon>"]) > max_SK_band:
            #     mode["class"] = "drifting"
            # print(mode["satnum"],"     exit",mode["class"],"mode, dr (phase) =", round(self.dr.by_phase[tm],4), "dr (mean) =", round(self.dr.by_mean[tm],4), "@",str(self.timestamps[tm])[:10])

            if mode["class"] == "in slot":
                if 0 < safedex(tm) < t_range-dexNday: self.events.append({"type":"exit","time":self.timestamps[tm],"lon":self.lon[tm],"alt":self.alt[tm]})
                if not self.retired: self.slots.append(mode)
            elif mode["class"] == "drifting":
                if 0 < safedex(tm) < t_range-dexNday: self.events.append({"type":"entry","time":self.timestamps[tm],"lon":self.lon[tm],"alt":self.alt[tm]})
            self.modes.append(mode)
            return mode, dexm
        def ID_check(tnow,idex):
            tdif = tnow - idex if idex is not None else tnow
            ldif = np.abs(np.max(self.lon[idex:tnow+1])-np.min(self.lon[idex:tnow+1]))              
            drifting = self.dr.by_phase[tnow] >= phase_dr_max or self.dr.by_mean[tnow] >= mean_dr_max
            toobig = ldif > max_SK_band
            toosoon = tdif < min_mode*dexNday
            ID = drifting or toobig
            return ID, toosoon
        def ED_check(tnow,idex):
            # check if mode duration is too short
            tdif = tnow - idex if idex is not None else tnow
            toosoon = tdif < min_mode*dexNday
            low_phase = self.dr.by_phase[tnow] <= phase_dr_max
            low_mean = self.dr.by_mean[tnow] <= mean_dr_max
            return low_phase, low_mean, toosoon, tnow < dexNday
        def go_back(_mode):
            etype = "entry"
            if _mode["class"] == "drifting" and len(self.slots) > 0: self.slots.pop(); etype = "exit"
            last_mode_event = None
            for e in range(len(self.events)):
                if self.events[e]["type"] == etype:
                    last_mode_event = e
            if last_mode_event is not None: self.events.pop(last_mode_event)
            if len(self.modes) > 0: self.modes.pop()
            lastmode = "in slot" if _mode["class"] == "drifting" else "drifting"
            mode, _ = enter_mode(_mode,last_dexit,lastmode)
            return mode, last_dexit
        for t in range(t_range):
            if np.min(self.alt[t:]) >= max_geo_alt and not self.retired:
                mode["orbit"] = "graveyard/storage"
                self.events.append({"type":"supersync","time":self.timestamps[t],"lon":self.lon[t],"alt":self.alt[t]})
                self.retired = True
            elif self.retired:
                mode["orbit"] = "GEO"
                self.retired = False
                self.events.append({"type":"sync","time":self.timestamps[t],"lon":self.lon[t],"alt":self.alt[t]})
            # if last t was in slot...
            if in_slot: # check for ID node
                ID, CT = ID_check(t,dex)
                if ID and CT:# if drifting & slot time < min_mode
                    mode, dex = go_back(mode)
                    in_slot = False # stop recording slot
                    in_drift = True # start recording drift
                # if slot time < min_mode, reset to last slot (time filter for cross-tagging)
                elif ID and t <= t_range-dexNday: # if drifting within last day
                    mode, last_dexit = exit_mode(mode,t,dex)
                    in_slot = False # stop recording slot
                    in_drift = True # start recording drift
                    mode, dex = enter_mode(mode,t,"drifting")
            # if last t was drifting, but dr is below threshold...
            elif in_drift:
                low_dr, low_m, CT, day1 = ED_check(t,dex)
                # if first timestep...
                if day1 and dex is None:
                    if not (low_dr and low_m) or np.max(self.dr.by_phase[0:int(min_mode*dexNday)]) >= phase_dr_max or np.max(self.dr.by_mean[0:int(min_mode*dexNday)]) >= mean_dr_max:
                        mode, dex = enter_mode(mode,t,"drifting")
                    else: mode, dex = enter_mode(mode,t,"in slot")
                # if drift time <= min_mode, reset to last slot (time filter for cross-tagging)
                elif low_dr and CT: # after first 24 hours, record slot
                    safe_dex = last_dexit-1 if (last_dexit is not None and last_dexit>0) else 0
                    if np.abs(self.lon[t] - self.lon[safe_dex]) <= max_SK_band:
                        mode, dex = go_back(mode)
                        in_slot = True # stop recording slot
                        in_drift = False # start recording drift                    
                        # else, initialize as in slot
                # elif not day1 and low_dr:
                #     in_slot = True
                #     in_drift = False
                #     mode, dex = enter_mode(mode,t,"in slot")
                # if mean dr <= noise threshold, enter slot & save last drift mode
                elif (low_dr and low_m) and t <= t_range-dexNday:
                    mode, last_dexit = exit_mode(mode,t,dex)
                    # self.modes.append(mode)
                    in_slot = True
                    in_drift = False
                    mode, dex = enter_mode(mode,t,"in slot")
                    # self.events.append({"type":"entry","time":self.timestamps[t],"lon":self.lon[t],"alt":self.alt[t]})
                # if last t was drifting & dr still high...
                elif dex is None: # first timestamp, initialize mode
                    mode, dex = enter_mode(mode,t,"drifting")
        mode, _ = exit_mode(mode,t,dex)
    
    def nodes(self):
        timestamps = []
        colors = []
        for i in range(len(self.modes)):
            if self.modes[i]["exit"] is not None:
                timestamps.append(self.modes[i]["exit"])
                if self.modes[i]["class"] == "in slot":
                    colors.append("PURPLE") # ID
                else: colors.append("GREEN") # ED
        return timestamps, colors

    def print(self):
        self.events.sort(key = lambda x:x['time'])
        print(self.satnum, "initially", self.modes[0]["class"],"@",round(self.lon[0],1),"degrees on",str(self.timestamps[0])[0:10])
        print("     ",len(self.modes)-1,"nodes found")
        for event in self.events:
            print("     ",str(event["time"])[0:16],"     ",event["type"],"event @",round(event["lon"],1),"degrees")
        print("     last known status:",self.modes[-1]["class"],"@",str(self.timestamps[-1])[0:16])

    def export_format(self):
        self.events.sort(key=lambda x: x['time'])
        event_timeline = {}
        event_timeline["M0"] = ' '.join([self.modes[0]["class"], "@", str(round(self.lon[0], 1)), "degrees on", str(self.timestamps[0])[0:19]])
        event_timeline["Mode-count"] = len(self.modes)
        event_timeline["Slot-count"] = len(self.slots)
        nodes = {}
        for event in self.events:
            nodes[str(event["time"])[0:19]] = ' '.join([event["type"], "event @", str(round(float(event["lon"]), 1)), "degrees"])
        mode = self.modes[-1]
        event_timeline["Nodes"] = nodes if len(nodes) > 0 else None
        event_timeline["Last Status"] = ' '.join([mode["class"], "@", str(round(mode["lon"], 1)), "degrees,", str(round(mode["alt"], 0)), "meters on", str(self.timestamps[-1])[0:19]])
        event_timeline["Min Lon"] = str(mode["lon>"])
        event_timeline["Max Lon"] = str(mode["lon<"])
        event_timeline["Dr m"] = str(mode["dr m<"]) + ", " + str(mode["dr m>"]) + ", " + str(mode["dr m"])
        event_timeline["Dr p"] = str(mode["dr p<"]) + ", " + str(mode["dr p>"]) + ", " + str(mode["dr p"])
        return event_timeline

